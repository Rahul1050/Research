# -*- coding: utf-8 -*-
"""stock_trading_strategy_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A-vTxJMkok_pfVBWo1QKENmIzh5S229s
"""

import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
import itertools

def fetch_stock_data(symbol, start_date, end_date):
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(start=start_date, end=end_date, interval="1h")
        if data.empty:
            print(f"No data found for {symbol}, skipping.")
            return None
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {str(e)}")
        return None

def process_data(data, symbol):
    if data is None or data.empty:
        return None

    df = data.reset_index()
    df['Symbol'] = symbol
    df['Volume_Float_Ratio'] = df['Volume'] / (df['Volume'].mean() * 10)  # Placeholder for float
    df['Volume_Per_Minute'] = df['Volume'] / 60
    df['Market_Force_Indicator'] = df['Volume_Per_Minute'] / (df['Volume'].mean() * 10)
    df['Volume_Per_Minute_Institutional_Transactions'] = df['Volume_Per_Minute'] * 0.1
    df['Relative Volume'] = df['Volume'] / df['Volume'].rolling(window=30).mean()
    df['Short Ratio'] = 5  # Placeholder
    return df

def generate_signals(df, thresholds, combination):
    if df is None or df.empty:
        return None

    conditions = []
    for indicator in combination:
        conditions.append(df[indicator] > thresholds[indicator])

    df['Buy_Signal'] = np.where(np.all(conditions, axis=0), 1, 0)

    # Modified sell condition to avoid early exits
    df['Sell_Signal'] = np.where(
        (df['Close'] < df['Close'].shift(1) * 0.98) |  # 2% stop loss
        (df['Close'] > df['Close'].shift(1) * 1.05),   # 5% take profit
        1, 0
    )
    return df

def calculate_performance(df, strategy_name, thresholds):
    if df is None or df.empty:
        return {
            'Total_Trades': 0,
            'Profitable_Trades': 0,
            'Total_Profit_Loss': 0,
            'Accuracy': 0
        }, []

    trades = []
    position = 0
    entry_price = 0
    entry_date = None

    for i, row in df.iterrows():
        if row['Buy_Signal'] == 1 and position == 0:
            position = 1
            entry_price = row['Close']
            entry_date = row['Datetime']
        elif (row['Sell_Signal'] == 1 or i == df.index[-1]) and position == 1:
            position = 0
            exit_price = row['Close']
            exit_date = row['Datetime']
            profit_loss = exit_price - entry_price
            trades.append({
                'Symbol': row['Symbol'],
                'Entry_Price': entry_price,
                'Exit_Price': exit_price,
                'Entry_Date': entry_date,
                'Exit_Date': exit_date,
                'Profit_Loss': profit_loss,
                'Strategy': strategy_name,
                'Thresholds': str(thresholds)
            })

    total_trades = len(trades)
    profitable_trades = sum(1 for trade in trades if trade['Profit_Loss'] > 0)
    total_profit_loss = sum(trade['Profit_Loss'] for trade in trades)
    accuracy = (profitable_trades / total_trades * 100) if total_trades > 0 else 0

    return {
        'Total_Trades': total_trades,
        'Profitable_Trades': profitable_trades,
        'Total_Profit_Loss': total_profit_loss,
        'Accuracy': accuracy
    }, trades

def main():
    symbols = ['NKE', 'ALL', 'OKE', 'EOG', 'EW', 'SNPS', 'SBAC', 'AIG', 'STZ', 'BXP', 'CINF', 'TXT', 'IRM', 'MKC', 'NLSN', 'TTWO', 'PKI', 'SPGI', 'WMT', 'BEN', 'TMO', 'LDOS', 'MRK', 'PBCT', 'XRAY', 'KMI', 'DOV', 'TGT', 'MET', 'UHS', 'TAP', 'WEC', 'RSG', 'HPE', 'BKR', 'PPG', 'FRC', 'DE', 'ACN', 'UAL', 'FDX', 'ADP', 'LOW', 'SWK', 'BLK', 'CDW', 'CNC', 'ALGN', 'AXP', 'AMT', 'XYL', 'CSCO', 'KHC', 'CL', 'PXD', 'LH', 'ORCL', 'SYY', 'NWL', 'KLAC', 'PYPL', 'CE', 'MU', 'WST', 'AMCR', 'FLS', 'NOC', 'HAS', 'LIN', 'CPRT', 'PLD', 'SCHW', 'GE', 'NTRS', 'V', 'WSO', 'TXN', 'J', 'MDLZ', 'VRTX', 'CSX', 'JNPR', 'PEAK', 'SYK', 'PKG', 'GS', 'AEP', 'NEE', 'NTAP', 'ADSK', 'IBM', 'AMP', 'COF', 'WM', 'VTRS', 'LEG', 'NSC', 'TTD', 'CF', 'PAYX', 'ABBV', 'MMC', 'EQIX', 'ECL', 'FISV', 'NVR', 'PWR', 'GD', 'PFE', 'GPC', 'IP', 'FE', 'HLT', 'OXY', 'ABT', 'LUV', 'L', 'CDNS', 'EFX', 'HST', 'AFL', 'EA', 'CAT', 'DOW', 'IEX', 'ITW', 'ODP', 'AVY', 'MSCI', 'SLG', 'KEYS', 'NFLX', 'AMZN', 'AZO', 'RE', 'FDS', 'ROK', 'ATVI', 'BRK.B', 'NOW', 'HWM', 'IPG', 'APD', 'SO', 'IART', 'LMT', 'FRT', 'MTD', 'VIAC', 'INTC', 'BIIB', 'HCA', 'WAT', 'DRI', 'GOOGL', 'RHI', 'VNO', 'MDT', 'ANTM', 'IDXX', 'MSFT', 'MCHP', 'MO', 'WFC', 'MHK', 'BSX', 'APTV', 'MOS', 'JPM', 'AMGN', 'FMC', 'KO', 'UNM', 'NVDA', 'MAS', 'MSI', 'QCOM', 'SRE', 'XOM', 'JNJ', 'MMM', 'CTAS', 'PFG', 'SBUX', 'RMD', 'EXC', 'TT', 'AVGO', 'AOS', 'TSLA', 'FAST', 'FLT', 'TYL', 'PVH', 'SEE', 'BWA', 'AJG', 'CTSH', 'SHW', 'DISH', 'PG', 'HIG', 'DLTR', 'FITB', 'FBHS', 'WBA', 'CHD', 'TFX', 'TSN', 'CB', 'TFC', 'BMY', 'BKNG', 'DVA', 'ZTS', 'CMCSA', 'HD', 'CMG', 'LUMN', 'NLOK', 'ADBE', 'USB', 'ZBH', 'MTB', 'UNH', 'CHTR', 'VRSK', 'TECH', 'AEE', 'VLO', 'JBHT', 'TEL', 'CCI', 'UPS', 'TER', 'D', 'TRV', 'DHR', 'GWW', 'APA', 'HON', 'SIVB', 'FB', 'ORI', 'GM', 'HII', 'COST', 'ROP', 'GRMN', 'PSA', 'LRCX', 'LII', 'NWSA', 'CFG', 'ISRG', 'AAPL', 'WRK', 'PM', 'HES', 'T', 'ES', 'SLB', 'HUM', 'MCO', 'AIV', 'ALLE', 'PEP', 'JKHY', 'WDC', 'MS', 'GLW', 'DUK', 'VZ', 'ICE', 'LKQ', 'DXCM', 'CVX', 'MAR', 'RTX', 'DG', 'WY', 'ADI', 'ABC', 'CI', 'BDX', 'CMA', 'LLY', 'PGR', 'BAX', 'KMB', 'DHI', 'NRG', 'CRM', 'ZBRA', 'UNP', 'AIZ', 'AVB', 'WHR', 'C', 'EL', 'STE', 'REGN', 'VTR', 'BA', 'ANSS', 'MCD', 'MA', 'TMUS', 'HBAN', 'SPG', 'A', 'HSY', 'NDSN', 'ODFL', 'AKAM', 'TPR', 'DIS', 'GILD', 'PHM', 'AON', 'FTV', 'LNC', 'CNP', 'CAG', 'YUM', 'DISCA']
    total_symbols = len(symbols)  # Total number of symbols to be processed

    end_date = datetime.now()
    start_date = end_date - timedelta(days=30)  # Analyze last 30 days

    threshold_ranges = {
        'Market_Force_Indicator': [0.0005, 0.001, 0.002],
        'Volume_Float_Ratio': [0.05, 0.1, 0.2],
        'Relative Volume': [1.5, 2.0, 2.5],
        'Short Ratio': [3.0, 5.0, 7.0],
        'Volume_Per_Minute': [3000, 5000, 7000],
        'Volume_Per_Minute_Institutional_Transactions': [500, 1000, 1500]
    }

    combinations = list(itertools.combinations(threshold_ranges.keys(), 3))

    results = []
    all_trades = []
    strategy_summary = []

    for count, symbol in enumerate(symbols, start=1):  # start=1 to start counting from 1
        print(f"Processing {count} out of {total_symbols}: {symbol}...")
        data = fetch_stock_data(symbol, start_date, end_date)
        if data is not None:
            df = process_data(data, symbol)
            if df is not None:
                for combo in combinations:
                    for thresholds in itertools.product(*[threshold_ranges[ind] for ind in combo]):
                        threshold_dict = dict(zip(combo, thresholds))
                        strategy_name = ', '.join(f"{ind}:{val}" for ind, val in threshold_dict.items())
                        df_signals = generate_signals(df.copy(), threshold_dict, combo)
                        if df_signals is not None:
                            performance, trades = calculate_performance(df_signals, strategy_name, threshold_dict)
                            all_trades.extend(trades)
                            strategy_summary.append({
                                'Strategy': strategy_name,
                                'Total_Profit_Loss': performance['Total_Profit_Loss'],
                                'Profitable_Trades': performance['Profitable_Trades'],
                                'Loss_Trades': performance['Total_Trades'] - performance['Profitable_Trades'],
                                'Profit_Percentage': performance['Accuracy'],
                                'Thresholds': str(threshold_dict)
                            })
                            results.append({
                                'Symbol': symbol,
                                'Combination': strategy_name,
                                'Total_Trades': performance['Total_Trades'],
                                'Profitable_Trades': performance['Profitable_Trades'],
                                'Total_Profit_Loss': performance['Total_Profit_Loss'],
                                'Accuracy': performance['Accuracy'],
                                'Thresholds': str(threshold_dict)
                            })
        time.sleep(1)  # To avoid hitting API rate limits

    results_df = pd.DataFrame(results)
    results_df.to_csv('indicator_combination_results.csv', index=False)
    print("Results saved to 'indicator_combination_results.csv'")

    trades_df = pd.DataFrame(all_trades)
    trades_df.to_csv('trades.csv', index=False)
    print("Trades saved to 'trades.csv'")

    strategy_summary_df = pd.DataFrame(strategy_summary)
    strategy_summary_df.to_csv('strategy_summary.csv', index=False)
    print("Strategy summary saved to 'strategy_summary.csv'")

    # Aggregate results
    aggregated_results = strategy_summary_df.groupby('Strategy').agg({
        'Total_Profit_Loss': 'sum',
        'Profitable_Trades': 'sum',
        'Loss_Trades': 'sum'
    }).reset_index()
    aggregated_results.to_csv('summary.csv', index=False)
    print("Aggregated results saved to 'summary.csv'")

main()